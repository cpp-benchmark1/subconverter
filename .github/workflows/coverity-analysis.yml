name: Coverity Scan
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      languages:
        description: "Languages to analyze"
        required: true
        default: "c-cpp"

jobs:
  coverity:
    runs-on: windows-latest
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
        - language: c-cpp
          build-mode: manual

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Download and Install Coverity Tool
        shell: powershell
        run: |
          $zipPath = "coverity_tool.zip"
          $form = @{
            token = "${{ secrets.COVERITY_TOKEN }}"
            project = "${{ github.repository }}"
          }
          $headers = @{
            "User-Agent" = "GitHubActions-Coverity"
          }

          $maxRetries = 3
          $retryCount = 0
          $downloadSuccess = $false

          while ($retryCount -lt $maxRetries -and -not $downloadSuccess)
          {
            $retryCount++
            Write-Output "Downloading Coverity tool (attempt $retryCount/$maxRetries)..."
            
            try
            {
              if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
              
              # Download with resume capability and better error handling
              $webClient = New-Object System.Net.WebClient
              $webClient.Headers.Add("User-Agent", "GitHubActions-Coverity")
              
              # Prepare form data manually for WebClient
              $boundary = [System.Guid]::NewGuid().ToString()
              $formData = "--$boundary`r`n"
              $formData += "Content-Disposition: form-data; name=`"token`"`r`n`r`n$($form.token)`r`n"
              $formData += "--$boundary`r`n"
              $formData += "Content-Disposition: form-data; name=`"project`"`r`n`r`n$($form.project)`r`n"
              $formData += "--$boundary--`r`n"
              
              $webClient.Headers.Add("Content-Type", "multipart/form-data; boundary=$boundary")
              $formBytes = [System.Text.Encoding]::UTF8.GetBytes($formData)
              
              try {
                $response = $webClient.UploadData("https://scan.coverity.com/download/win64", "POST", $formBytes)
                [System.IO.File]::WriteAllBytes($zipPath, $response)
              }
              finally {
                $webClient.Dispose()
              }
              
              if (-not (Test-Path $zipPath)) {
                throw "File not created after download"
              }
              
              $fileSize = (Get-Item $zipPath).Length
              Write-Output "Downloaded file size: $fileSize bytes"
              
              if ($fileSize -lt 1000000) {
                Write-Output "File seems too small, checking content..."
                $content = Get-Content $zipPath -Raw -Encoding UTF8
                if ($content -match "error|Error|ERROR") {
                  throw "Download returned error page instead of zip file"
                }
              }
              
              # Validate zip file with more robust check
              try {
                # First try basic file header check
                $fileStream = [System.IO.File]::OpenRead($zipPath)
                $buffer = New-Object byte[] 4
                $fileStream.Read($buffer, 0, 4) | Out-Null
                $fileStream.Close()
                
                # Check for ZIP file signature (PK)
                if ($buffer[0] -ne 0x50 -or $buffer[1] -ne 0x4B) {
                  throw "File does not have ZIP signature"
                }
                
                # Now try full ZIP validation
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
                $entryCount = $zip.Entries.Count
                
                # Verify we can read the central directory
                $firstEntry = $zip.Entries[0]
                $null = $firstEntry.Name
                
                $zip.Dispose()
                Write-Output "Zip file validated with $entryCount entries"
                $downloadSuccess = $true
              }
              catch {
                throw "Zip file integrity check failed: $($_.Exception.Message)"
              }
            }
            catch
            {
              Write-Output "Download attempt $retryCount failed: $($_.Exception.Message)"
              if ($retryCount -lt $maxRetries) {
                Write-Output "Waiting 30 seconds before retry..."
                Start-Sleep -Seconds 30
              }
            }
          }
          
          if (-not $downloadSuccess) {
            Write-Error "Failed to download Coverity tool after $maxRetries attempts"
            exit 1
          }

          Write-Output "Extracting Coverity tool..."
          New-Item -ItemType Directory -Path "coverity_tool" -Force | Out-Null
          Expand-Archive $zipPath -DestinationPath "coverity_tool" -Force
          $Env:PATH = "$PWD\coverity_tool\bin;$Env:PATH"
          New-Item -ItemType Directory -Path "cov-int" -Force | Out-Null
          Write-Output "Coverity Tool installed successfully"
          Get-ChildItem -Recurse coverity_tool

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: base-devel git mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake mingw-w64-x86_64-pcre2 mingw-w64-x86_64-libxml2 patch
          path-type: inherit

      - name: Build with Coverity
        shell: msys2 {0}
        run: |
          covFolder=$(find coverity_tool -type d -name 'cov-analysis-win64*' | head -n1)
          if [ -z "$covFolder" ]; then
            echo "Could not find the cov-analysis-win64 folder inside coverity_tool"
            exit 1
          fi
          covPath="$covFolder/bin/cov-build.exe"
          echo "Using Coverity at: $covPath"
          SHA=$(git rev-parse --short HEAD)
          sed -i 's/\(v[0-9]\.[0-9]\.[0-9]\)/\1-'"$SHA"'/' src/version.h
          echo "Listing structure under coverity_tool (max 3 levels):"
          find coverity_tool -type d -maxdepth 3 || true
          echo "Listing top-level directories:"
          ls -1 || true
          
          # Ensure clean build directory
          rm -rf cov-int
          mkdir -p cov-int
          mkdir -p cov-int/output
          
          # Run cov-build and capture both stdout and stderr
          set +e
          "$covPath" --dir cov-int bash -lc "./scripts/build.windows.release.sh VERBOSE=1" 2>&1 | tee cov-int/build-log.txt
          build_exit_code=$?
          set -e
          
          echo "Build exit code: $build_exit_code"
          
          # Ensure we have the required files
          if [ ! -f "cov-int/build-log.txt" ]; then
            echo "Creating build-log.txt from build output"
            touch cov-int/build-log.txt
          fi
          
          # Create minimal cli-diagnostics.json if it doesn't exist
          if [ ! -f "cov-int/output/cli-diagnostics.json" ]; then
            echo "Creating minimal cli-diagnostics.json"
            mkdir -p cov-int/output
            echo '{"format_version": "1.0", "warnings": [], "errors": []}' > cov-int/output/cli-diagnostics.json
          fi
      - name: Verify Coverity output
        shell: msys2 {0}
        run: |
          echo "Checking for required Coverity artifacts..."
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la || true
          echo ""
          
          echo "Checking cov-int directory structure:"
          if [ -d "cov-int" ]; then
            echo "cov-int directory exists"
            echo "cov-int contents:"
            ls -la cov-int/ || true
            echo ""
            
            if [ -d "cov-int/output" ]; then
              echo "cov-int/output directory exists"
              echo "cov-int/output contents:"
              ls -la cov-int/output/ || true
            else
              echo "cov-int/output directory missing"
            fi
            echo ""
          else
            echo "cov-int directory missing!"
            exit 1
          fi
          
          # Check for required files
          found_artifact=false
          
          if [ -f "cov-int/build-log.txt" ]; then
            echo "build-log.txt found"
            echo "build-log.txt size: $(du -h cov-int/build-log.txt)"
            found_artifact=true
          else
            echo "build-log.txt not found"
          fi
          
          if [ -f "cov-int/output/cli-diagnostics.json" ]; then
            echo "cli-diagnostics.json found"
            echo "cli-diagnostics.json size: $(du -h cov-int/output/cli-diagnostics.json)"
            found_artifact=true
          else
            echo "cli-diagnostics.json not found"
          fi
          
          if [ "$found_artifact" = false ]; then
            echo "No required Coverity artifacts found!"
            echo "Full directory tree:"
            find cov-int -type f || true
            exit 1
          else
            echo "Required Coverity artifacts verified successfully"
          fi
      - name: Compress Results
        shell: powershell
        run: |
          Compress-Archive -Path cov-int -DestinationPath myproject.zip
        id: compress

      - name: Submit to Coverity Scan
        shell: powershell
        run: |
          Write-Output "Submitting results to Coverity Scan..."
          try {
            # Create multipart form data manually
            $boundary = [System.Guid]::NewGuid().ToString()
            $LF = "`r`n"
            
            # Read the zip file
            $fileBytes = [System.IO.File]::ReadAllBytes("myproject.zip")
            $fileName = "myproject.zip"
            
            # Build the form data
            $bodyLines = @()
            $bodyLines += "--$boundary"
            $bodyLines += "Content-Disposition: form-data; name=`"token`""
            $bodyLines += ""
            $bodyLines += "${{ secrets.COVERITY_TOKEN }}"
            
            $bodyLines += "--$boundary"
            $bodyLines += "Content-Disposition: form-data; name=`"email`""
            $bodyLines += ""
            $bodyLines += "${{ secrets.COVERITY_EMAIL }}"
            
            $bodyLines += "--$boundary"
            $bodyLines += "Content-Disposition: form-data; name=`"version`""
            $bodyLines += ""
            $bodyLines += "${{ github.sha }}"
            
            $bodyLines += "--$boundary"
            $bodyLines += "Content-Disposition: form-data; name=`"description`""
            $bodyLines += ""
            $bodyLines += "Automated Coverity Scan from GitHub Actions"
            
            $bodyLines += "--$boundary"
            $bodyLines += "Content-Disposition: form-data; name=`"file`"; filename=`"$fileName`""
            $bodyLines += "Content-Type: application/zip"
            $bodyLines += ""
            
            # Convert text part to bytes
            $bodyText = $bodyLines -join $LF
            $bodyTextBytes = [System.Text.Encoding]::UTF8.GetBytes($bodyText + $LF)
            
            # Create closing boundary
            $closingBoundary = ($LF + "--$boundary--" + $LF)
            $closingBytes = [System.Text.Encoding]::UTF8.GetBytes($closingBoundary)
            
            # Combine all parts
            $totalBytes = $bodyTextBytes + $fileBytes + $closingBytes
            
            # Make the request
            $webClient = New-Object System.Net.WebClient
            $webClient.Headers.Add("Content-Type", "multipart/form-data; boundary=$boundary")
            
            try {
              $response = $webClient.UploadData("https://scan.coverity.com/builds?project=${{ secrets.COVERITY_PROJECT_NAME }}", "POST", $totalBytes)
              $responseText = [System.Text.Encoding]::UTF8.GetString($response)
              Write-Output "Successfully submitted to Coverity Scan"
              Write-Output "Response: $responseText"
            }
            finally {
              $webClient.Dispose()
            }
          }
          catch {
            Write-Error "Failed to submit to Coverity: $($_.Exception.Message)"
            exit 1
          }