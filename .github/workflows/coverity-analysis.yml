name: Coverity Scan
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      languages:
        description: "Languages to analyze"
        required: true
        default: "c-cpp"

jobs:
  coverity:
    runs-on: windows-latest
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
        - language: c-cpp
          build-mode: manual

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Download and Install Coverity Tool
        shell: powershell
        run: |
          $zipPath = "coverity_tool.zip"
          $form = @{
            token = "${{ secrets.COVERITY_TOKEN }}"
            project = "${{ github.repository }}"
          }
          $headers = @{
            "User-Agent" = "GitHubActions-Coverity"
          }

          Write-Output "‚¨áÔ∏è Downloading Coverity tool..."
          try {
            Invoke-WebRequest -Uri "https://scan.coverity.com/download/win64" `
              -Method Post `
              -Headers $headers `
              -ContentType "application/x-www-form-urlencoded" `
              -Body $form `
              -OutFile $zipPath -UseBasicParsing
          } catch {
            Write-Error "‚ùå Failed to download Coverity tool: $($_.Exception.Message)"
            exit 1
          }

          if (-not (Test-Path $zipPath)) {
            Write-Error "‚ùå Coverity zip not found after download!"
            exit 1
          }

          New-Item -ItemType Directory -Path "coverity_tool" -Force | Out-Null
          Expand-Archive $zipPath -DestinationPath "coverity_tool" -Force
          $Env:PATH = "$PWD\coverity_tool\bin;$Env:PATH"
          New-Item -ItemType Directory -Path "cov-int" -Force | Out-Null
          Write-Output "‚úÖ Coverity Tool installed successfully"
          Get-ChildItem -Recurse coverity_tool

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: base-devel git mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake mingw-w64-x86_64-pcre2 mingw-w64-x86_64-libxml2 patch python
          path-type: inherit

      - name: Build with Coverity
        shell: msys2 {0}
        run: |
          echo "üîç Environment information:"
          echo "MINGW_PREFIX: $MINGW_PREFIX"
          echo "PATH: $PATH"
          echo "Current directory: $(pwd)"
          echo "MSYSTEM: $MSYSTEM"
          echo "All environment variables:"
          env | sort

          # Set MINGW_PREFIX if not already set
          if [ -z "$MINGW_PREFIX" ]; then
            echo "‚ö†Ô∏è MINGW_PREFIX not set, trying to determine it..."
            if [ "$MSYSTEM" = "MINGW64" ]; then
              export MINGW_PREFIX="/mingw64"
              echo "‚úÖ Set MINGW_PREFIX to $MINGW_PREFIX based on MSYSTEM"
            elif [ -d "/mingw64" ]; then
              export MINGW_PREFIX="/mingw64"
              echo "‚úÖ Set MINGW_PREFIX to /mingw64 (found directory)"
            elif [ -d "/c/msys64/mingw64" ]; then
              export MINGW_PREFIX="/c/msys64/mingw64"
              echo "‚úÖ Set MINGW_PREFIX to /c/msys64/mingw64 (GitHub Actions path)"
            else
              echo "‚ùå Cannot determine MINGW_PREFIX"
              echo "Available directories in /mingw64:"
              ls -la /mingw64/ 2>/dev/null || echo "/mingw64 not accessible"
              echo "Available directories in /c/msys64:"
              ls -la /c/msys64/ 2>/dev/null || echo "/c/msys64 not accessible"
              exit 1
            fi
          fi

          echo "‚úÖ Final MINGW_PREFIX: $MINGW_PREFIX"
          echo "‚úÖ MINGW_PREFIX exists: $(test -d "$MINGW_PREFIX" && echo "Yes" || echo "No")"

          # Convert Windows paths to MSYS2 paths if needed
          if [[ "$MINGW_PREFIX" == D:* ]]; then
            echo "üîÑ Converting Windows path to MSYS2 path..."
            ORIGINAL_MINGW_PREFIX="$MINGW_PREFIX"
            MINGW_PREFIX=$(cygpath -u "$MINGW_PREFIX" 2>/dev/null || echo "$MINGW_PREFIX")
            echo "Original: $ORIGINAL_MINGW_PREFIX"
            echo "Converted: $MINGW_PREFIX"
            echo "cygpath command: cygpath -u '$ORIGINAL_MINGW_PREFIX'"
            cygpath -u "$ORIGINAL_MINGW_PREFIX" 2>/dev/null || echo "cygpath conversion failed"
          fi

          # Additional MSYS2 path setup
          echo "üîß Setting up MSYS2 environment..."
          export MSYS2_PATH_TYPE=inherit

          # Check MSYS2 mount points
          echo "Checking MSYS2 mount points:"
          mount | head -10 || echo "mount command not available"
          df -h | head -10 || echo "df command not available"

          echo "‚úÖ Final MSYS2 MINGW_PREFIX: $MINGW_PREFIX"
          echo "‚úÖ MSYS2 MINGW_PREFIX exists: $(test -d "$MINGW_PREFIX" && echo "Yes" || echo "No")"

          # Check if we need to use MSYS2 mount points
          if [ ! -d "$MINGW_PREFIX" ]; then
            echo "‚ö†Ô∏è MINGW_PREFIX directory not found, checking MSYS2 mount points..."
            # Try to find the actual MSYS2 installation
            if [ -d "/mingw64" ]; then
              export MINGW_PREFIX="/mingw64"
              echo "‚úÖ Found /mingw64, using it as MINGW_PREFIX"
            elif [ -d "/c/msys64/mingw64" ]; then
              export MINGW_PREFIX="/c/msys64/mingw64"
              echo "‚úÖ Found /c/msys64/mingw64, using it as MINGW_PREFIX"
            else
              echo "‚ùå Cannot find MSYS2 installation"
              echo "Checking common locations:"
              ls -la /mingw64/ 2>/dev/null || echo "/mingw64 not accessible"
              ls -la /c/msys64/ 2>/dev/null || echo "/c/msys64 not accessible"
              ls -la /d/a/_temp/ 2>/dev/null | head -10 || echo "/d/a/_temp not accessible"
              exit 1
            fi
          fi

          echo "‚úÖ Final working MINGW_PREFIX: $MINGW_PREFIX"
          echo "‚úÖ Directory exists: $(test -d "$MINGW_PREFIX" && echo "Yes" || echo "No")"

          # Create include directory if it doesn't exist
          if [ ! -d "$MINGW_PREFIX/include" ]; then
            echo "üìÅ Creating $MINGW_PREFIX/include directory..."
            install -d "$MINGW_PREFIX/include" || {
              echo "‚ùå Failed to create $MINGW_PREFIX/include"
              echo "Checking parent directory permissions:"
              ls -la "$(dirname "$MINGW_PREFIX")" 2>/dev/null || echo "Cannot access parent directory"
              exit 1
            }
          fi

          covFolder=$(find coverity_tool -type d -name 'cov-analysis-win64*' | head -n1)
          if [ -z "$covFolder" ]; then
            echo "‚ùå Could not find the cov-analysis-win64 folder inside coverity_tool"
            exit 1
          fi
          covPath="$covFolder/bin/cov-build.exe"
          echo "‚úÖ Using Coverity at: $covPath"
          SHA=$(git rev-parse --short HEAD)
          sed -i 's/\(v[0-9]\.[0-9]\.[0-9]\)/\1-'"$SHA"'/' src/version.h
          echo "Listing structure under coverity_tool (max 3 levels):"
          find coverity_tool -type d -maxdepth 3 || true
          echo "Listing top-level directories:"
          ls -1 || true

          # Generate compile_commands.json first
          echo "üîß Generating compile_commands.json..."
          mkdir -p build
          cd build
          echo "Building in directory: $(pwd)"
          echo "CMake configure command: cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_PREFIX_PATH=\"$MINGW_PREFIX\" -G \"Unix Makefiles\" .."
          cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_PREFIX_PATH="$MINGW_PREFIX" -G "Unix Makefiles" ..
          cd ..
          echo "‚úÖ compile_commands.json generated"

          # Run Coverity build analysis
          echo "üîç Running Coverity analysis..."
          echo "Coverity command: $covPath --dir cov-int bash -lc './scripts/build.windows.release.sh VERBOSE=1'"
          "$covPath" --dir cov-int bash -lc "./scripts/build.windows.release.sh VERBOSE=1"

          # Test if headers are available
          echo "üîß Testing if headers are available..."
          echo "Searching for rapidjson:"
          find "$MINGW_PREFIX/include/" -name "*rapidjson*" 2>/dev/null || echo "No rapidjson files found"
          find /mingw64/include/ -name "*rapidjson*" 2>/dev/null || echo "No rapidjson files in /mingw64/include"
          find /usr/include/ -name "*rapidjson*" 2>/dev/null || echo "No rapidjson files in /usr/include"

          echo "Searching for toml11:"
          find "$MINGW_PREFIX/include/" -name "*toml*" 2>/dev/null || echo "No toml files found"
          find /mingw64/include/ -name "*toml*" 2>/dev/null || echo "No toml files in /mingw64/include"
          find /usr/include/ -name "*toml*" 2>/dev/null || echo "No toml files in /usr/include"

          # Test if we can find the headers manually
          echo "üîß Manual header verification:"
          echo "Checking for rapidjson.h:"
          find "$MINGW_PREFIX/include/" -name "rapidjson.h" -type f 2>/dev/null || echo "rapidjson.h not found in MINGW_PREFIX"
          find /mingw64/include/ -name "rapidjson.h" -type f 2>/dev/null || echo "rapidjson.h not found in /mingw64/include"
          find /usr/include/ -name "rapidjson.h" -type f 2>/dev/null || echo "rapidjson.h not found in /usr/include"

          echo "Checking for toml.hpp:"
          find "$MINGW_PREFIX/include/" -name "toml.hpp" -type f 2>/dev/null || echo "toml.hpp not found in MINGW_PREFIX"
          find /mingw64/include/ -name "toml.hpp" -type f 2>/dev/null || echo "toml.hpp not found in /mingw64/include"
          find /usr/include/ -name "toml.hpp" -type f 2>/dev/null || echo "toml.hpp not found in /usr/include"

          # Copy compile_commands.json to root directory
          echo "üìã Copying compile_commands.json to root..."
          cp build/compile_commands.json . || echo "‚ö†Ô∏è Warning: compile_commands.json not found in build directory"
          echo "‚úÖ compile_commands.json copied to root"

          # Verify library installations
          echo "üîç Verifying library installations..."
          echo "MINGW_PREFIX: $MINGW_PREFIX"
          echo "Converted MINGW_PREFIX (MSYS2): $(cygpath -u "$MINGW_PREFIX" 2>/dev/null || echo 'cygpath not available')"

          # Check if MINGW_PREFIX exists and is accessible
          if [ -n "$MINGW_PREFIX" ] && [ -d "$MINGW_PREFIX" ]; then
            echo "‚úÖ MINGW_PREFIX directory exists: $MINGW_PREFIX"
            echo "Contents of MINGW_PREFIX/include:"
            ls -la "$MINGW_PREFIX/include/" | head -20

            echo "Looking for toml.hpp:"
            find "$MINGW_PREFIX/include/" -name "toml.hpp" 2>/dev/null || echo "toml.hpp not found in MINGW_PREFIX"

            echo "Looking for rapidjson directory:"
            find "$MINGW_PREFIX/include/" -name "*rapidjson*" -type d 2>/dev/null || echo "rapidjson directory not found in MINGW_PREFIX"

            echo "Looking for rapidjson.h:"
            find "$MINGW_PREFIX/include/" -name "rapidjson.h" 2>/dev/null || echo "rapidjson.h not found in MINGW_PREFIX"
          else
            echo "‚ö†Ô∏è Warning: MINGW_PREFIX not set or directory does not exist"
            echo "Checking common MSYS2 locations:"
            ls -la /mingw64/include/ 2>/dev/null | head -10 || echo "/mingw64/include not accessible"
            ls -la /usr/include/ 2>/dev/null | head -10 || echo "/usr/include not accessible"
          fi

          echo "üîç CMake search paths that will be used:"
          echo "  - MINGW_PREFIX/include: $MINGW_PREFIX/include"
          echo "  - /mingw64/include"
          echo "  - /usr/include"
          echo "  - GitHub Actions MSYS2 paths"

          # Generate cli-diagnostics.json using our script
          echo "üìã Generating cli-diagnostics.json..."
          bash scripts/generate-coverity-diagnostics.sh || echo "‚ö†Ô∏è Warning: Failed to generate cli-diagnostics.json with script"

          # Copy cli-diagnostics.json if it exists (either from Coverity or our script)
          if [ -f "cov-int/output/cli-diagnostics.json" ]; then
            echo "üìã Copying cli-diagnostics.json to root..."
            cp cov-int/output/cli-diagnostics.json . || echo "‚ö†Ô∏è Warning: cli-diagnostics.json not found"
            echo "‚úÖ cli-diagnostics.json copied to root"
          elif [ -f "cli-diagnostics.json" ]; then
            echo "‚úÖ cli-diagnostics.json already available in root directory"
          else
            echo "‚ö†Ô∏è Warning: cli-diagnostics.json not found in either location"
          fi
      - name: Verify Coverity output
        shell: msys2 {0}
        run: |
          echo "üîç Verifying generated files..."

          # Check compile_commands.json
          if [ -f "compile_commands.json" ]; then
            echo "‚úÖ compile_commands.json found in root directory"
            echo "üìä compile_commands.json size: $(stat --format=%s compile_commands.json) bytes"
          else
            echo "‚ùå compile_commands.json not found in root directory!"
            exit 1
          fi

          # Check cli-diagnostics.json
          if [ -f "cli-diagnostics.json" ]; then
            echo "‚úÖ cli-diagnostics.json found in root directory"
            echo "üìä cli-diagnostics.json size: $(stat --format=%s cli-diagnostics.json) bytes"
          elif [ -f "cov-int/output/cli-diagnostics.json" ]; then
            echo "‚úÖ cli-diagnostics.json found in cov-int/output/"
          else
            echo "‚ùå cli-diagnostics.json not found!"
            echo "Listing cov-int contents:"
            ls -R cov-int || true
            exit 1
          fi

          # Check other Coverity outputs
          if [ -f "cov-int/build-log.txt" ]; then
            echo "‚úÖ build-log.txt found"
          else
            echo "‚ùå build-log.txt not found!"
            exit 1
          fi

          echo "üéâ All required files generated successfully!"
      - name: Compress Results
        shell: powershell
        run: |
          # Create a temporary directory for all artifacts
          New-Item -ItemType Directory -Path "artifacts" -Force | Out-Null
          Copy-Item -Path "cov-int" -Destination "artifacts" -Recurse -Force
          if (Test-Path "compile_commands.json") {
            Copy-Item -Path "compile_commands.json" -Destination "artifacts" -Force
          }
          if (Test-Path "cli-diagnostics.json") {
            Copy-Item -Path "cli-diagnostics.json" -Destination "artifacts" -Force
          }
          Compress-Archive -Path artifacts -DestinationPath myproject.zip
          Write-Output "üì¶ Artifacts compressed successfully"
          Remove-Item -Path "artifacts" -Recurse -Force
        id: compress

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "coverity-scan-${{ github.run_id }}"
          release_name: "Coverity Scan Results"
          body: "Automated Coverity Scan Results"
          draft: false
          prerelease: false

      - name: Upload Asset to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: myproject.zip
          asset_name: myproject.zip
          asset_content_type: application/x-bzip2

      - name: Notify Coverity Scan
        shell: powershell
        run: |
          Invoke-WebRequest -Uri "https://scan.coverity.com/builds" -Method Post -Body @{
            project     = "${{ github.repository }}"
            token       = "${{ secrets.COVERITY_TOKEN }}"
            email       = "cpp.benchmark@proton.me"
            url         = "https://github.com/${{ github.repository }}/releases/download/coverity-scan-${{ github.run_id }}/myproject.zip"
            version     = "1.0"
            description = "Automated Coverity Scan"
          }